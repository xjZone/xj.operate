<!doctype html>
<html lang="zh-cmn-hans">
<head>
<meta charset="utf-8" />
<meta name="renderer" content="webkit" />
<meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1" />

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.2/css/all.min.css" />
<script src="https://cdn.jsdelivr.net/npm/jquery@3.6.1/dist/jquery.min.js"></script>
<script src="./static/cj/xj.plugins.setting.js"></script>

<script src="https://cdn.jsdelivr.net/npm/fastclick@1.0.6/lib/fastclick.min.js"></script>
<script>document.addEventListener('DOMContentLoaded',function(){
FastClick.attach(document.body)},false);</script>

<meta name="viewport" xj-viewport="{minWidth:400, }" content="width=device-width,initial-scale=1" />
<script src="https://cdn.jsdelivr.net/gh/xjZone/xj.viewport@0.3.2/dist/xj.viewport.min.js"></script>

<script src="https://cdn.jsdelivr.net/gh/xjZone/xj.storage@0.2.2/dist/xj.storage.min.js"></script>
<!-- <script src="https://cdn.jsdelivr.net/gh/xjZone/xj.
operate@0.6.0/dist/xj.operate.min.js"></script> -->
<script src="./dist/xj.operate.min.js"></script>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/xjZone/xj.ripple@0.3.2/dist/xj.ripple.min.css" />
<script src="https://cdn.jsdelivr.net/gh/xjZone/xj.ripple@0.3.2/dist/xj.ripple.min.js"></script>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/xjZone/xj.focus@0.3.2/dist/xj.focus.min.css" />
<script src="https://cdn.jsdelivr.net/gh/xjZone/xj.focus@0.3.2/dist/xj.focus.min.js"></script>

<link rel="stylesheet" href="./static/plugin/xj.base/0.4.0/dist/xj.base.min.css" />
<script src="./static/plugin/xj.base/0.4.0/dist/xj.base.min.js"></script>

<script src="./static/plugin/xjArrive/0.3.2/dist/xjArrive.min.js"></script>

<link id="prism-theme-white" rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prism-themes@1.9.0/themes/prism-material-light.min.css" />
<link id="prism-theme-black" rel="alternate stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.25.0/themes/prism-okaidia.min.css" />
<script data-manual="prevent prism auto highlighted pre or code" src="https://cdn.jsdelivr.net/npm/prismjs@1.25.0/prism.min.js"></script>

<link rel="stylesheet" href="./static/plugin/xjDemo/0.1.0/dist/xjDemo.min.css" />
<script src="./static/plugin/xjDemo/0.1.0/dist/xjDemo.min.js"></script>

<link rel="stylesheet" href="./static/plugin/xjScroll/0.4.0/dist/xjScroll.min.css" />
<script src="./static/plugin/xjScroll/0.4.0/dist/xjScroll.min.js"></script>

<link rel="stylesheet" href="./static/plugin/xjDir/0.2.0/dist/xjDir.min.css" />
<script src="./static/plugin/xjDir/0.2.0/dist/xjDir.min.js"></script>

<!-- ↑ Public | Private ↓ -->

<link rel="stylesheet" href="./static/cj/index.css?date=2022-10-14" />
<script src="./static/cj/index.js?date=2022-10-14"></script>
<!-- <script>document.write('<link rel="stylesheet" href="./static/cj/index.css?timeStamp='+ Date.now() +'" />')</script>
<script>document.write('<script src="./static/cj/index.js?timeStamp='+ Date.now() +'"><\/script>')</script> -->

<title>xj.operate</title>
</head>
<body>



<div id="pub_side">
	<div id="pub_sidePack">
		<div id="pub_sideMask"></div>
		<div id="pub_sideWrap">
			
			<div class="xjScroll" id="xjScroll01" xjScroll="{native:true, resizeCallbackType:'none', }" style="width:100%;height:100%;">
				<div class="xjDir" id="xjDir01" xjDir="{}" style="padding:8px;width:100%;border-right:none;font-family:inherit;">
					<ul>
						<li class="xjDir-spread xjDir-active">
							<a href="javascript:void(0)">
								<i class="xjDir-icon fas fa-arrow-pointer"></i>
								<i class="xjDir-text">xj.operate</i>
								<i class="xjDir-sign"></i>
							</a>
							<ul id="xjDir01_ul01"></ul>
						</li>
						
						<li class="xjDir-divide"></li>
						
						<li class="xjDir-spread">
							<a href="javascript:void(0)">
								<i class="xjDir-icon fas fa-cubes"></i>
								<i class="xjDir-text">xjZone</i>
								<i class="xjDir-sign"></i>
							</a>
							<ul id="xjDir01_ul02"></ul>
						</li>
					</ul>
				</div>
			</div>
			
		</div>
	</div>
</div>



<div id="pub_head">
	<div id="pub_headPack">
		<h1 id="pub_headText"><a class="a-unset" href="">xj.operate<small> 判断操作方式</small></a></h1>
		
		<form id="pub_headForm" target="_blank" enctype="text/plain" title="Press Enter to Search" action="https://github.com/xjZone/xj.operate/search">
			<input id="pub_headFormText" class="input-plain" name="q" type="search" autocomplete="off" placeholder="Search" />
			<label id="pub_headFormIcon" class="fas fa-search" for="pub_headFormText"></label>
		</form>
		
		<a id="pub_headCode" class="button" title="Get Source from GitHub" target="_blank" 
		 href="https://github.com/xjZone/xj.operate/"> <i class="fab fa-github"></i> </a>
	</div>
</div>



<main id="pub_main">
<div id="pub_mainPack">



<section>
<h2>基本介绍</h2>

<p><b>简介</b> : 这个插件主要用于判断用户的操作方式，究竟是用鼠标操作还是触屏操作，在引入了这个插件之后，当用户使用鼠标进行操作时 <code>&lt;html&gt;</code> 上将会出现 <code>xj-operate-mouse</code> 的类，当用户使用触屏进行操作时 <code>&lt;html&gt;</code> 上将会出现 <code>xj-operate-touch</code> 的类，这两个类名的设置并非是一次性的，它会根据用户的操作模式进行动态监听和变化，这有助于我们根据用户不同的操作方式进行不同的设置。</p>

<p><b>兼容</b> : IE10+ / Edge12+ / Firefox / Chrome / Safari / Opera / IOS Webkit / Android Platform</p>

<p><b>更新</b> : <a target="_blank" href="https://github.com/xjZone/xj.operate/blob/master/upgrade.md">https://github.com/xjZone/xj.operate/blob/master/upgrade.md</a></p>

<p><b>源码</b> : <a target="_blank" href="https://github.com/xjZone/xj.operate/">https://github.com/xjZone/xj.operate/</a></p>

<p><b>协议</b> : <a target="_blank" href="https://www.apache.org/licenses/LICENSE-2.0">Apache License, V2.0</a></p>

<p><b>版本</b> : <select class="select-unset"><option selected="selected">0.6.0</option></select></p>

<hr />
</section>



<section>
<h2>引入插件</h2>
<p>首先是引入相关的文件，推荐使用带 <a target="_blank" href="https://www.cnblogs.com/ziyunfei/p/5642796.html" class="">immutable</a> 的 <a target="_blank" href="https://www.jsdelivr.com/">JSDelivr</a> CDN：</p>

<textarea class="xjDemo" xjDemo="{onlySource:true}">
<script src="https://cdn.jsdelivr.net/gh/xjZone/xj.operate@0.6.0/dist/xj.operate.min.js"></script>
</textarea>

<hr />
</section>



<section>
<h2>如何使用</h2>
<p>如果使用了鼠标进行操作，那么 <code>html</code> 标签会被添加 <code>xj-operate-mouse</code> 类名，如果使用了触屏进行操作，那么 <code>html</code> 标签会被添加 <code>xj-operate-touch</code> 类名，如果既不是鼠标也不是触屏，那么 <code>html</code> 标签会被添加 <code>xj-operate-other</code> 类名，但除非是手动调用了 <code>xj.operate.otherSet()</code> 方法，否则 <code>other</code> 状态一般都不会自动出现的，下面是一个简单的例子，什么状态就显示什么关键词：</p>

<textarea class="xjDemo" xjDemo="{}">
<style>
.span{display:none;}
.xj-operate-mouse .mouse{display:inline;}
.xj-operate-touch .touch{display:inline;}
.xj-operate-other .other{display:inline;}
</style>

<p> 当前状态 : 
	<span class="span mouse">mouse</span>
	<span class="span touch">touch</span>
	<span class="span other">other</span>
</p>
</textarea>

<hr />
</section>



<section>
<h2>让 hover 在触屏时无效</h2>
<p><code>:hover</code> 伪类选择器用于定义元素被鼠标悬停时的样式，但它在 touch 触屏操作的环境下表现就不是那么让人满意了，主要是触屏操作并不像鼠标那样有所谓的悬停状态，所以得点击后才能生效，它也没有像鼠标挪开这样的概念，所以得等到元素失焦后才会失效，这就造成了有时样式并不符合预期结果的情况，因此有人会希望触屏操作时不要让这个选择器生效，现在借助 xj.operate 插件可轻松实现了。</p>

<textarea class="xjDemo" xjDemo="{}">
<style>
/* .cube01 的 :hover 只会在鼠标操作时生效，如果是触屏操作则无视，这样可以解决移动端的沾黏问题 */
/* 如果你不了解什么是沾黏，可参考一下这个页面 : https://stackoverflow.com/questions/17233804/ */
.cube{display:inline-block;width:80px;height:80px;border:1px solid #ccc;}
.xj-operate-mouse .cube01:hover{background-color:#39f;}
.cube02:hover{background-color:#39f;}
</style>

<!-- 不能聚焦在 Safari(IOS) 中无法将响应 hover -->
<!-- 所以我们为两个 div 添加了 tabIndex 的属性 -->
<div class="cube cube01" tabIndex="0">cube01</div>
<div class="cube cube02" tabIndex="0">cube02</div>
</textarea>

<hr />
</section>



<section>
<h2>通过配置控制长按结果</h2>
<p>在上个例子中我们已经展示了如何让 <code>:hover</code> 选择器不在触屏操作时生效，但如果你觉得在触屏操作时完全禁止 <code>:hover</code> 的样式有些不妥，那么也许可以考虑使用插件提供的折中方案，那就是通过全局配置中的 <code>pressHover</code> 参数，来允许触屏模式下让长按操作能响应 <code>:hover</code> 选择器，其工作原理是判断到长按就临时切换为鼠标的状态，之后如果再次触发了 <code>touchstart</code> 事件就恢复为触屏的状态。</p>

<textarea class="xjDemo" xjDemo="{sourceShow:true, resultContent:'为了避免全局配置影响到当前页面，所以我们创建了一个新页面展示效果&lt;br /&gt;查看 Demo 页面 : &lt;a target=&quot;_blank&quot; href=&quot;./page/demo_01_touchPressHover.html&quot;&gt;touchPressHover.html&lt;/a&gt;',}">
<script>
// 可在引入插件前通过 xj.operateConfig['0.6.0'] 进行全局配置
// 中括号的值得和当前插件版本(0.6.0)相同，这是考虑多版本并存
if(window.xj === undefined){ xj = {} };
if(xj.operateConfig === undefined){ xj.operateConfig = {} };

// pressHover 参数默认为 false，为 true 时如果处于触屏的状态
// 长按屏幕且没移动过，就临时转遍为鼠标状态，来让 hover 生效
xj.operateConfig['0.6.0'] = { pressHover : true, };
</script>
<script src="https://cdn.jsdelivr.net/gh/xjZone/xj.operate@0.6.0/dist/xj.operate.min.js"></script>

<style>
/* 代码和上例完全相同，但全局配置 pressHover 为 true */
/* 所以 .cube01 在触屏操作模式下时，长按可响应 hover */
.cube{display:inline-block;width:80px;height:80px;border:1px solid #ccc;}
.xj-operate-mouse .cube01:hover{background-color:#39f;}
.cube02:hover{background-color:#39f;}
</style>

<!-- 不能聚焦在 Safari(IOS) 中无法将响应 hover -->
<!-- 所以我们为两个 div 添加了 tabIndex 的属性 -->
<div class="cube cube01" tabIndex="0">cube01</div>
<div class="cube cube02" tabIndex="0">cube02</div>
</textarea>

<hr />
</section>



<section>
<h2>通过配置自定义类名</h2>
<p>如果你觉得插件提供的默认类名如 <code>xj-operate-mouse</code> 或 <code>xj-operate-touch</code> 实在是太长了，那么可通过全局配置进行修改，但实际上 XJ 并不推荐修改默认类名，因为 XJ 系列插件都是只响应这些默认类名而已，如果修改了可能会引发一些样式错误，但我们还是可以通过全局配置的 <code>mouseCallback</code>, <code>touchCallback</code>, <code>otherCallback</code> 这三个回调方法，在状态被改变的时候同时进行类名的设置。</p>

<textarea class="xjDemo" xjDemo="{sourceShow:true, resultContent:'为了避免全局配置影响到当前页面，所以我们创建了一个新页面展示效果&lt;br /&gt;查看 Demo 页面 : &lt;a target=&quot;_blank&quot; href=&quot;./page/demo_02_customClassName.html&quot;&gt;customClassName.html&lt;/a&gt;',}">
<script>
// 可在引入插件前通过 xj.operateConfig['0.6.0'] 进行全局配置
// 中括号的值得和当前插件版本(0.6.0)相同，这是考虑多版本并存
if(window.xj === undefined){ xj = {} };
if(xj.operateConfig === undefined){ xj.operateConfig = {} };

// xj-operate-* 被改成了简短的 is*
// 且将类名改在 body 上而不是 html
var dbc = document.body.classList;
xj.operateConfig['0.6.0'] = {
	mouseCallback: function(){ dbc.add('isMouse'), dbc.remove('isTouch'), dbc.remove('isOther') },
	touchCallback: function(){ dbc.add('isTouch'), dbc.remove('isMouse'), dbc.remove('isOther') },
	otherCallback: function(){ dbc.add('isOther'), dbc.remove('isMouse'), dbc.remove('isTouch') },
};
</script>
<script src="https://cdn.jsdelivr.net/gh/xjZone/xj.operate@0.6.0/dist/xj.operate.min.js"></script>

<style>
.span{display:none;}
.isMouse .mouse{display:inline;}
.isTouch .touch{display:inline;}
.isOther .other{display:inline;}
</style>

<p> 当前状态 : 
	<span class="span mouse">mouse</span>
	<span class="span touch">touch</span>
	<span class="span other">other</span>
</p>
</textarea>

<hr />
</section>



<section>
<h2>手动调整当前状态</h2>
<p>插件对象提供了 <code>xj.operate.mouseSet()</code>, <code>xj.operate.touchSet()</code>, <code>xj.operate.otherSet()</code> 这三个方法，用于手动改变当前的状态，但是这些改变都是暂时的，在调用了这些方法之后，一旦再次触发 <code>mousemove</code> 事件或者 <code>touchstart</code> 事件，就会恢复为原本的自然状态，除非是在调用这三个方法时传入 <code>false</code> 参数，那样就不会自动恢复了，更多细节可以参考之后的 <code>xj.operate</code> 对象。</p>

<textarea class="xjDemo" xjDemo="{}">
<style>
.case{display:none;}
.xj-operate-mouse .mouse{display:inline;}
.xj-operate-touch .touch{display:inline;}
.xj-operate-other .other{display:inline;}
</style>

<p> 当前状态 : 
	<span class="case mouse">mouse</span>
	<span class="case touch">touch</span>
	<span class="case other">other</span>
</p>

<p>
	<!-- Android 的部分浏览器在插上鼠标后进行点击，会额外的在 click 事件后再自动触发一个 mousemove 事件 -->
	<!-- 这个额外的 mousemove 事件将导致插件总是误判为 mouse 鼠标状态，所以使用 setTimeout 延迟后再设置 -->
	<!-- 这个额外的 mousemove 事件并不会影响插件的判断，只有在使用 click 事件手动调整状态时，才需要延迟 -->
	<button type="button" onclick="setTimeout(function(){ xj.operate.mouseSet() }, 50)">mouseSet()</button>
	<button type="button" onclick="setTimeout(function(){ xj.operate.touchSet() }, 50)">touchSet()</button>
	<button type="button" onclick="setTimeout(function(){ xj.operate.otherSet() }, 50)">otherSet()</button>
</p>
</textarea>

<hr />
</section>



<section>
<h2>xj.operate 对象</h2>
<p><code>xj.operate</code> 对象除了 <code>mouseSet()</code>, <code>touchSet()</code>, <code>otherSet()</code> 这三个方法之外，还有其他一些属性，下面都罗列一下，值得注意的是三个改变状态的方法，改变默认都是暂时性的，之后用户再次触发相关事件，将恢复为正常状态，除非是调用它们时传入 <code>false</code> 参数，此时如果不再重新调用一次 <code>mouseSet()</code> 或 <code>touchSet()</code> 或 <code>otherSet()</code>，则不会再自动恢复监听，也就是说状态将固化。</p>

<textarea class="xjDemo" xjDemo="{result:false, larger:true}">
<script>
console.log( xj.operate.version );	// 插件和配置的版本号
	
console.log( xj.operate.mouse );			// 是否正处于 mouse 状态，是则返回 true，否则返回 fasle
console.log( xj.operate.touch );			// 是否正处于 touch 状态，是则返回 true，否则返回 fasle
console.log( xj.operate.other );			// 是否正处于 other 状态，是则返回 true，否则返回 fasle，实际上这个状态并不会自动出现，除非是手动调用了 otherSet()

console.log( xj.operate.mouseSet(temporary) );		// 手动设置为 mouse 状态，可传入 temporary 参数，不传则默认是 true，也就是设置状态是临时的，传入 false 则永久性进入 mouse 状态，得再次调用 mouseSet() | touchSet() | otherSet() 才能恢复继续监听
console.log( xj.operate.touchSet(temporary) );		// 手动设置为 touch 状态，可传入 temporary 参数，不传则默认是 true，也就是设置状态是临时的，传入 false 则永久性进入 touch 状态，得再次调用 mouseSet() | touchSet() | otherSet() 才能恢复继续监听
console.log( xj.operate.otherSet(temporary) );		// 手动设置为 other 状态，可传入 temporary 参数，不传则默认是 true，也就是设置状态是临时的，传入 false 则永久性进入 other 状态，得再次调用 mouseSet() | touchSet() | otherSet() 才能恢复继续监听
</script>
</textarea>

<hr />
</section>



<section>
<h2>全局配置</h2>
<p>全局配置的对象，用于控制节点类名的设置，长按操作和时间间隔，状态被改变时的回调等内容，需要注意的是，全局配置得在引入插件前就设置好，否则插件加载并执行的时候找不到配置，就会认为配置不存在，并且版本号还要对得上，否则插件也不会理会的，例如本页面使用的插件是 0.6.0 的版本，在 <code>xj.operateConfig</code> 对象后面跟着的就是 <code>['0.6.0']</code>，版本匹配是考虑到多版本并存而设计的。</p>

<textarea class="xjDemo" xjDemo="{result:false, larger:true}">
<script>
// 中括号里的是版本号
if(window.xj === undefined){ xj = {} };
if(xj.operateConfig === undefined){ xj.operateConfig = {} };
xj.operateConfig['0.6.0'] = {
	
	classTarget : document.documentElement,	// 将被添加 existClass | mouseClass | touchClass | otherClass 类名的节点，默认 html 标签，建议保持默认别修改
	existClass : 'xj-operate-exist',		// 初始化后 classTarget 会被添加的类名，默认是 'xj-operate-exist'，可用于 CSS 判断是否有存在 xj.operate 插件
	
	mouseClass : 'xj-operate-mouse',		// 当使用了鼠标进行操作，会在 classTarget 节点上添加的类名，默认是 'xj-operate-mouse'，并不推荐修改，因为不少 xj 插件都是默认只响应这个类名，如果需要配置其他类名，可在 mouseCallback 回调中设置
	touchClass : 'xj-operate-touch',		// 当使用了触屏进行操作，会在 classTarget 节点上添加的类名，默认是 'xj-operate-touch'，并不推荐修改，因为不少 xj 插件都是默认只响应这个类名，如果需要配置其他类名，可在 touchCallback 回调中设置
	otherClass : 'xj-operate-other',		// 既不是鼠标也不是触屏，会在 classTarget 节点上添加的类名，默认是 'xj-operate-other'，但实际上这个状态并不会自动出现，页面只会在 mouse 和 touch 这两个状态中进行切换，除非是主动调用 otherSet()
	
	pressHover : false,						// 当处于 touch 状态时，如果长按屏幕且没有移动过，是否临时转遍为 mouse 状态，以便让 hover 生效，默认为 false
	delayTime : 500,						// touchstart 和 mousemove 的最大间隔时间，在此时间内触发连续触发这两个事件，将会进入 mouse 状态，默认为 500
	
	mouseCallback : function(temp){},		// 触发为 mouse 状态的回调函数，temporary 参数是这个状态是否为临时性转遍的标志，一般都是 true，除非调用 mouseSet() 时传入了 false，如果该函数最终返回的是 false，那么将会阻止本次进入 mouse 状态
	touchCallback : function(temp){},		// 触发为 touch 状态的回调函数，temporary 参数是这个状态是否为临时性转遍的标志，一般都是 true，除非调用 touchSet() 时传入了 false，如果该函数最终返回的是 false，那么将会阻止本次进入 touch 状态
	otherCallback : function(temp){},		// 既不是 mouse 也不是 touch 的回调函数，temporary 参数是调用 otherSet() 传入的参数，这个函数返回 false 将阻止进入 other 状态，实际上 other 状态并不会自动出现，这回调只在调用 otherSet() 时响应
	
};
</script>
</textarea>

<hr />
</section>



<section>
<h2>判断原理</h2>

<p>如何判断当前是使用鼠标操作还是触屏操作？有些开发者会以浏览器是否支持 <code>touchstart</code> 事件做为依据，支持就认为是使用了触屏操作，然而这种判断方法并不可靠，因为支持该事件的设备，也可能是使用着鼠标进行操作的，使用鼠标的环境下设备也可能是支持触屏操作的，那么怎么做才更加准确呢？浏览器目前并没有提供任何关于用户操作模式的 API，但是我们可以曲折的实现，以下是判断的原理。</p>

<p>在支持触屏的环境下，常规的触屏点击会按顺序先触发 <code>touchstart</code> 再触发 <code>mousemove</code>，所以我们可以使用这两个事件的时间间隔来进行判断，如果 <code>touchstart</code> 和 <code>mousemove</code> 的触发时间间隔大于 <code>500ms</code>，那就认为这两个事件并非是同个点击操作导致的，所以此时是使用了鼠标，如果这两个事件的触发时间间隔小于 <code>500ms</code>，则认为它们是由于触屏点击而同时触发的，那么此时是使用了触屏。</p>

<p>之所以使用 <code>500</code> 毫秒进行判断，是因为在部分移动端的浏览器如 Safari(IOS) 中，<a target="_blank" href="https://stackoverflow.com/questions/12238587">点击相关的事件存在 300 毫秒的延迟</a>，而事件如果延迟 <code>500</code> 毫秒以上就是长按而不是点击了，所以小于 <code>500</code> 毫秒是比较适中的，兼顾到了延迟和长按，当然实际上判断操作还要考虑事件的真实性(<code>event.isTrusted</code>)和滚动或捏合缩放等，但这些都是插件的细节，就不过多讲述了，有兴趣的可自行查看插件源码。</p>

<hr />
</section>



<section>
<h2>项目备注</h2>

<p>01. <code>:hover</code> 和 <code>:active</code> 这两个伪类选择器在 Safari(IOS) 中存在问题，具体来讲就是如果目标节点无法被聚焦或点击时没有特殊效果，那么这个节点就无法正常响应这两个伪类选择器，解决这问题的常用手段有两种，一是给目标节点绑定 <code>touchstart</code> 事件，回调是个空函数也无所谓，二是给目标节点设置 <code>tabIndex</code> 属性，让节点变得可被聚焦，在之前 "让 hover 在触屏时无效" 的案例中，我们就采用了第二种方法来确保 <code>:hover</code> 伪类生效，但这个问题并不会出现在 <code>button</code> 和 <code>a</code> 这些本来就可聚焦或可点击的元素上。</p>

<p>02. 插件判断设备类型其实是动态的，因为存在触屏设备插上鼠标变成鼠标操控，或 PC 转为触屏模式如 Chrome 使用移动端模拟，所以动态监听下适应性会更好，但状态的改变还得等对应的事件被触发，也就是说改变并不是立刻生效的，起码得移动过鼠标或触屏过才行。</p>

<p>03. 有疑问或者发现 BUG，可到 GitHub 提 <a target="_blank" href="https://github.com/xjZone/xj.operate/issues">Issue</a>，如果觉得插件写得还行，在 GitHub 中为本项目点个 <a target="_blank" href="https://github.com/xjZone/xj.operate">★Star</a> 吧，感谢啦 ಠ‿ಠ ❤。</p>

<hr />
</section>



<section>
<h2>推荐阅读</h2>
<p>XJ.Chen - <a target="_blank" href="https://juejin.cn/post/7159655319084204068">浅谈 :hover 伪类选择器在 touch 环境如何禁止生效的问题</a></p>
<hr />
</section>



</div>
</main>



<div id="pub_foot">
	<div id="pub_footPack">
		<div>Copyright © 2015-<script>document.write(new Date().getFullYear())</script> XJ.Chen All Rights Reserved</div>
		<div>More XJ Plugins : <a target="_blank" href="https://github.com/xjZone/">https://github.com/xjZone/</a></div>
	</div>
</div>

<div id="pub_tool">
	<div id="pub_toolPack">
		<button id="pub_toolSwitchDir" type="button" title="Switch The Dir"><i class="fas fa-list-ul"></i></button>
		<button id="pub_toolBackToTop" type="button" title="Back to Top"><i class="fas fa-angles-up"></i></button>
	</div>
</div>



</body>
</html>


