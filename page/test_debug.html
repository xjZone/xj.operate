<!doctype html>
<html lang="zh-cmn-hans">
<head>
<meta charset="utf-8" />
<meta name="renderer" content="webkit" />
<meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1" />
<meta name="viewport" content="width=device-width,initial-scale=1" />

<meta name="viewport" xj-viewport="{minWidth:400, }" content="width=device-width,initial-scale=1" />
<script src="https://cdn.jsdelivr.net/gh/xjZone/xj.viewport@0.3.2/dist/xj.viewport.min.js"></script>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.2/css/all.min.css" />
<script src="https://cdn.jsdelivr.net/npm/fastclick@1.0.6/lib/fastclick.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jquery@3.6.1/dist/jquery.min.js"></script>
<script src="../static/cj/xj.plugins.setting.js"></script>

<script src="https://cdn.jsdelivr.net/gh/xjZone/xj.storage@0.2.2/dist/xj.storage.min.js"></script>
<!-- <script src="https://cdn.jsdelivr.net/gh/xjZone/xj.operate@0.6.0/dist/xj.operate.min.js"></script> -->

<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/xjZone/xj.ripple@0.3.2/dist/xj.ripple.min.css" />
<script src="https://cdn.jsdelivr.net/gh/xjZone/xj.ripple@0.3.2/dist/xj.ripple.min.js"></script>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/xjZone/xj.focus@0.3.2/dist/xj.focus.min.css" />
<script src="https://cdn.jsdelivr.net/gh/xjZone/xj.focus@0.3.2/dist/xj.focus.min.js"></script>

<link id="prism-theme-white" rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prism-themes@1.9.0/themes/prism-material-light.css" />
<link id="prism-theme-black" rel="alternate stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.25.0/themes/prism-okaidia.css" />
<script data-manual="prevent prism auto highlighted pre or code" src="https://cdn.jsdelivr.net/npm/prismjs@1.25.0/prism.js"></script>

<script src="https://cdn.jsdelivr.net/npm/prismjs@1.24.1/plugins/keep-markup/prism-keep-markup.min.js"></script>
<style>.xjDemo-pack .xjDemo-body-source-wrap > code mark{background-color:rgba(255,255,64,1.00);}</style>

<link rel="stylesheet" href="../static/plugin/xjDemo/0.1.0/dist/xjDemo.min.css" />
<script src="../static/plugin/xjDemo/0.1.0/dist/xjDemo.min.js"></script>

<!-- <script>document.addEventListener('DOMContentLoaded',function(){FastClick.attach(document.body)},false);</script> -->
<!-- <style>html[class~="xj-base-black"] body{background-color:#333;color:#fff;}</style> -->

<!--◇
<link rel="stylesheet" href="../static/plugin/xj.base/0.4.0/dist/xj.base.css" />
<script src="../static/plugin/xj.base/0.4.0/dist/xj.base.js"></script>
◇-->

<!--◇
<link rel="stylesheet" href="../dist/xj.operate.css" />
<script src="../dist/xj.operate.js"></script>
◇-->

<style>
@font-face{font-family:"Iosevka";src:local('Iosevka'), url("../static/font/iosevka/6.1.2/iosevka-fixed-regular.woff2") format("woff2"), url("../static/font/iosevka/6.1.2/iosevka-fixed-regular.woff") format("woff");}
a{background-color:transparent;text-decoration:none;cursor:pointer;color:#39f;} html:not(.xj-operate-touch) a:hover{text-decoration:underline;color:#4af;}
body{box-sizing:border-box;margin:0;padding:0 32px;max-width:1024px;font:16px/1.5 Iosevka,'Microsoft YaHei','Hiragino Sans GB';}
code{padding:0 8px;background-color:#f0f0f0;color:#f39;font-family:inherit;}
a > code{color:inherit;}
</style>
<title>xj.operate_debug</title>
</head>
<body>



<section>
<h2>开发备注</h2>

<p>
使用鼠标则 <code>html</code> 标签会被添加 <code>xj-operate-mouse</code> 的类名<br />
使用触屏则 <code>html</code> 标签会被添加 <code>xj-operate-touch</code> 的类名<br />
</p>

<p>
样式只在使用鼠标时生效可这样写 : <code>.xj-operate-mouse button:hover{}</code><br />
样式只在使用触屏时生效可这样写 : <code>.xj-operate-touch button:hover{}</code><br />
</p>

<p>
可以使用这样的选择器来进行设置样式 <code>html:not(.xj-operate-touch) button:hover{}</code><br />
在非触屏的状态才有 <code>hover</code> 样式，这样即使没引入 xj.operate 插件，也能够正常生效<br />
</p>

<p>
不管是 <code>html</code> 类名，还是 <code>xj.operate.mouse</code> 或 <code>xj.operate.touch</code> 属性，都是会动态变化的<br />
条件为 <code>touchstart</code> 和 <code>mousemove</code> 的触发间隔是否在 500ms 之内，是为 touch，否则为 mouse<br />
</p>

<p>
类名默认设置在 <code>html</code> 标签上，是因为插件被加载时 <code>body</code> 标签不一定存在，但 <code>html</code> 标签总是存在的<br />
当不是鼠标也不是触屏的状态时 <code>html</code> 标签会被添加 <code>xj-operate-other</code> 类名，但是该状态不会主动出现<br />
状态总在 <code>mouse</code> 和 <code>touch</code> 之间切换，手动调用 <code>xj.operate.otherSet()</code> 方法才会进入 <code>other</code> 状态<br />
</p>

<p>
理想上来讲移动端在插上鼠标后就该变成鼠标状态，目前大部分浏览器也是如此，但老旧浏览器可能不是这样<br />
Android UC 和 Android Firefox，早期这两个浏览器插上鼠标可被检测出来，但点击后会变成 <code>touch</code> 状态<br />
这是因为这两个浏览器用鼠标点击，除 PC 端那套事件外，还会同时触发 <code>touchstart</code> 和 <code>touchend</code> 事件<br />
</p>

<hr />
</section>



<section>
<h2>引入插件</h2>
<p>首先是引入相关的文件，推荐使用带 <a target="_blank" href="https://www.cnblogs.com/ziyunfei/p/5642796.html" class="">immutable</a> 的 <a target="_blank" href="https://www.jsdelivr.com/">JSDelivr</a> CDN：</p>

<textarea class="xjDemo" xjDemo="{onlySource:true}">
<script src="https://cdn.jsdelivr.net/gh/xjZone/xj.operate@0.6.0/dist/xj.operate.min.js"></script>
</textarea>

<hr />
</section>



<section>
<h2>如何使用</h2>
<p>如果使用了鼠标进行操作，那么 <code>html</code> 标签会被添加 <code>xj-operate-mouse</code> 类名，如果使用了触屏进行操作，那么 <code>html</code> 标签会被添加 <code>xj-operate-touch</code> 类名，如果既不是鼠标也不是触屏，那么 <code>html</code> 标签会被添加 <code>xj-operate-other</code> 类名，但除非是手动调用了 <code>xj.operate.otherSet()</code> 方法，否则 <code>other</code> 状态一般都不会自动出现的，下面是一个简单的例子，什么状态就显示什么关键词：</p>

<textarea class="xjDemo" xjDemo="{}">
<style>
.span{display:none;}
.xj-operate-mouse .mouse{display:inline;}
.xj-operate-touch .touch{display:inline;}
.xj-operate-other .other{display:inline;}
</style>

<p> 当前状态 : 
	<span class="span mouse">mouse</span>
	<span class="span touch">touch</span>
	<span class="span other">other</span>
</p>
</textarea>

<hr />
</section>



<section>
<h2>让 hover 在触屏时无效</h2>
<p><code>:hover</code> 伪类选择器用于定义元素被鼠标悬停时的样式，但它在 touch 触屏操作的环境下表现就不是那么让人满意了，主要是触屏操作并不像鼠标那样有所谓的悬停状态，所以得点击后才能生效，它也没有像鼠标挪开这样的概念，所以得等到元素失焦后才会失效，这就造成了有时样式并不符合预期结果的情况，因此有人会希望触屏操作时不要让这个选择器生效，现在借助 xj.operate 插件可轻松实现了。</p>

<textarea class="xjDemo" xjDemo="{}">
<style>
/* .cube01 的 :hover 只会在鼠标操作时生效，如果是触屏操作则无视，这样可以解决移动端的沾黏问题 */
/* 如果你不了解什么是沾黏，可参考一下这个页面 : https://stackoverflow.com/questions/17233804/ */
.cube{display:inline-block;width:80px;height:80px;border:1px solid #ccc;}
.xj-operate-mouse .cube01:hover{background-color:#39f;}
.cube02:hover{background-color:#39f;}
</style>

<!-- 不能聚焦在 Safari(IOS) 中无法将响应 hover -->
<!-- 所以我们为两个 div 添加了 tabIndex 的属性 -->
<div class="cube cube01" tabIndex="0">cube01</div>
<div class="cube cube02" tabIndex="0">cube02</div>
</textarea>

<hr />
</section>



<section>
<h2>通过配置控制长按结果</h2>
<p>在上个例子中我们已经展示了如何让 <code>:hover</code> 选择器不在触屏操作时生效，但如果你觉得在触屏操作时完全禁止 <code>:hover</code> 的样式有些不妥，那么也许可以考虑使用插件提供的折中方案，那就是通过全局配置中的 <code>pressHover</code> 参数，来允许触屏模式下让长按操作能响应 <code>:hover</code> 选择器，其工作原理是判断到长按就临时切换为鼠标的状态，之后如果再次触发了 <code>touchstart</code> 事件就恢复为触屏的状态。</p>

<textarea class="xjDemo" xjDemo="{sourceShow:true, resultContent:'为了避免全局配置影响到当前页面，所以我们创建了一个新页面展示效果&lt;br /&gt;查看 Demo 页面 : &lt;a target=&quot;_blank&quot; href=&quot;./demo_01_touchPressHover.html&quot;&gt;touchPressHover.html&lt;/a&gt;',}">
<script>
// 可在引入插件前通过 xj.operateConfig['0.6.0'] 进行全局配置
// 中括号的值得和当前插件版本(0.6.0)相同，这是考虑多版本并存
if(window.xj === undefined){ xj = {} };
if(xj.operateConfig === undefined){ xj.operateConfig = {} };

// pressHover 参数默认为 false，为 true 时如果处于触屏的状态
// 长按屏幕且没移动过，就临时转遍为鼠标状态，来让 hover 生效
xj.operateConfig['0.6.0'] = { pressHover : true, };
</script>
<script src="https://cdn.jsdelivr.net/gh/xjZone/xj.operate@0.6.0/dist/xj.operate.min.js"></script>

<style>
/* 代码和上例完全相同，但全局配置 pressHover 为 true */
/* 所以 .cube01 在触屏操作模式下时，长按可响应 hover */
.cube{display:inline-block;width:80px;height:80px;border:1px solid #ccc;}
.xj-operate-mouse .cube01:hover{background-color:#39f;}
.cube02:hover{background-color:#39f;}
</style>

<!-- 不能聚焦在 Safari(IOS) 中无法将响应 hover -->
<!-- 所以我们为两个 div 添加了 tabIndex 的属性 -->
<div class="cube cube01" tabIndex="0">cube01</div>
<div class="cube cube02" tabIndex="0">cube02</div>
</textarea>

<hr />
</section>



<section>
<h2>通过配置自定义类名</h2>
<p>如果你觉得插件提供的默认类名如 <code>xj-operate-mouse</code> 或 <code>xj-operate-touch</code> 实在是太长了，那么可通过全局配置进行修改，但实际上 XJ 并不推荐修改默认类名，因为 XJ 系列插件都是只响应这些默认类名而已，如果修改了可能会引发一些样式错误，但我们还是可以通过全局配置的 <code>mouseCallback</code>, <code>touchCallback</code>, <code>otherCallback</code> 这三个回调方法，在状态被改变的时候同时进行类名的设置。</p>

<textarea class="xjDemo" xjDemo="{sourceShow:true, resultContent:'为了避免全局配置影响到当前页面，所以我们创建了一个新页面展示效果&lt;br /&gt;查看 Demo 页面 : &lt;a target=&quot;_blank&quot; href=&quot;./demo_02_customClassName.html&quot;&gt;customClassName.html&lt;/a&gt;',}">
<script>
// 可在引入插件前通过 xj.operateConfig['0.6.0'] 进行全局配置
// 中括号的值得和当前插件版本(0.6.0)相同，这是考虑多版本并存
if(window.xj === undefined){ xj = {} };
if(xj.operateConfig === undefined){ xj.operateConfig = {} };

// xj-operate-* 被改成了简短的 is*
// 且将类名改在 body 上而不是 html
var dbc = document.body.classList;
xj.operateConfig['0.6.0'] = {
	mouseCallback: function(){ dbc.add('isMouse'), dbc.remove('isTouch'), dbc.remove('isOther') },
	touchCallback: function(){ dbc.add('isTouch'), dbc.remove('isMouse'), dbc.remove('isOther') },
	otherCallback: function(){ dbc.add('isOther'), dbc.remove('isMouse'), dbc.remove('isTouch') },
};
</script>
<script src="https://cdn.jsdelivr.net/gh/xjZone/xj.operate@0.6.0/dist/xj.operate.min.js"></script>

<style>
.span{display:none;}
.isMouse .mouse{display:inline;}
.isTouch .touch{display:inline;}
.isOther .other{display:inline;}
</style>

<p> 当前状态 : 
	<span class="span mouse">mouse</span>
	<span class="span touch">touch</span>
	<span class="span other">other</span>
</p>
</textarea>

<hr />
</section>



<section>
<h2>手动调整当前状态</h2>
<p>插件对象提供了 <code>xj.operate.mouseSet()</code>, <code>xj.operate.touchSet()</code>, <code>xj.operate.otherSet()</code> 这三个方法，用于手动改变当前的状态，但是这些改变都是暂时的，在调用了这些方法之后，一旦再次触发 <code>mousemove</code> 事件或者 <code>touchstart</code> 事件，就会恢复为原本的自然状态，除非是在调用这三个方法时传入 <code>false</code> 参数，那样就不会自动恢复了，更多细节可以参考之后的 <code>xj.operate</code> 对象。</p>

<textarea class="xjDemo" xjDemo="{}">
<style>
.case{display:none;}
.xj-operate-mouse .mouse{display:inline;}
.xj-operate-touch .touch{display:inline;}
.xj-operate-other .other{display:inline;}
</style>

<p> 当前状态 : 
	<span class="case mouse">mouse</span>
	<span class="case touch">touch</span>
	<span class="case other">other</span>
</p>

<p>
	<!-- Android 的部分浏览器在插上鼠标后进行点击，会额外的在 click 事件后再自动触发一个 mousemove 事件 -->
	<!-- 这个额外的 mousemove 事件将导致插件总是误判为 mouse 鼠标状态，所以使用 setTimeout 延迟后再设置 -->
	<!-- 这个额外的 mousemove 事件并不会影响插件的判断，只有在使用 click 事件手动调整状态时，才需要延迟 -->
	<button type="button" onclick="setTimeout(function(){ xj.operate.mouseSet() }, 50)">mouseSet()</button>
	<button type="button" onclick="setTimeout(function(){ xj.operate.touchSet() }, 50)">touchSet()</button>
	<button type="button" onclick="setTimeout(function(){ xj.operate.otherSet() }, 50)">otherSet()</button>
</p>
</textarea>

<hr />
</section>



<section>
<h2>xj.operate 对象</h2>
<p><code>xj.operate</code> 对象除了 <code>mouseSet()</code>, <code>touchSet()</code>, <code>otherSet()</code> 这三个方法之外，还有其他一些属性，下面都罗列一下，值得注意的是三个改变状态的方法，改变默认都是暂时性的，之后用户再次触发相关事件，将恢复为正常状态，除非是调用它们时传入 <code>false</code> 参数，此时如果不再重新调用一次 <code>mouseSet()</code> 或 <code>touchSet()</code> 或 <code>otherSet()</code>，则不会再自动恢复监听，也就是说状态将固化。</p>

<textarea class="xjDemo" xjDemo="{result:false, larger:true}">
<script>
console.log( xj.operate.version );	// 插件和配置的版本号
	
console.log( xj.operate.mouse );			// 是否正处于 mouse 状态，是则返回 true，否则返回 fasle
console.log( xj.operate.touch );			// 是否正处于 touch 状态，是则返回 true，否则返回 fasle
console.log( xj.operate.other );			// 是否正处于 other 状态，是则返回 true，否则返回 fasle，实际上这个状态并不会自动出现，除非是手动调用了 otherSet()

console.log( xj.operate.mouseSet(temporary) );		// 手动设置为 mouse 状态，可传入 temporary 参数，不传则默认是 true，也就是设置状态是临时的，传入 false 则永久性进入 mouse 状态，得再次调用 mouseSet() | touchSet() | otherSet() 才能恢复继续监听
console.log( xj.operate.touchSet(temporary) );		// 手动设置为 touch 状态，可传入 temporary 参数，不传则默认是 true，也就是设置状态是临时的，传入 false 则永久性进入 touch 状态，得再次调用 mouseSet() | touchSet() | otherSet() 才能恢复继续监听
console.log( xj.operate.otherSet(temporary) );		// 手动设置为 other 状态，可传入 temporary 参数，不传则默认是 true，也就是设置状态是临时的，传入 false 则永久性进入 other 状态，得再次调用 mouseSet() | touchSet() | otherSet() 才能恢复继续监听
</script>
</textarea>

<hr />
</section>



<section>
<h2>全局配置</h2>
<p>全局配置的对象，用于控制节点类名的设置，长按操作和时间间隔，状态被改变时的回调等内容，需要注意的是，全局配置得在引入插件前就设置好，否则插件加载并执行的时候找不到配置，就会认为配置不存在，并且版本号还要对得上，否则插件也不会理会的，例如本页面使用的插件是 0.6.0 的版本，在 <code>xj.operateConfig</code> 对象后面跟着的就是 <code>['0.6.0']</code>，版本匹配是考虑到多版本并存而设计的。</p>

<textarea class="xjDemo" xjDemo="{result:false, larger:true}">
<script>
// 中括号里的是版本号
if(window.xj === undefined){ xj = {} };
if(xj.operateConfig === undefined){ xj.operateConfig = {} };
xj.operateConfig['0.6.0'] = {
	
	classTarget : document.documentElement,	// 将被添加 existClass | mouseClass | touchClass | otherClass 类名的节点，默认 html 标签，建议保持默认别修改
	existClass : 'xj-operate-exist',		// 初始化后 classTarget 会被添加的类名，默认是 'xj-operate-exist'，可用于 CSS 判断是否有存在 xj.operate 插件
	
	mouseClass : 'xj-operate-mouse',		// 当使用了鼠标进行操作，会在 classTarget 节点上添加的类名，默认是 'xj-operate-mouse'，并不推荐修改，因为不少 xj 插件都是默认只响应这个类名，如果需要配置其他类名，可在 mouseCallback 回调中设置
	touchClass : 'xj-operate-touch',		// 当使用了触屏进行操作，会在 classTarget 节点上添加的类名，默认是 'xj-operate-touch'，并不推荐修改，因为不少 xj 插件都是默认只响应这个类名，如果需要配置其他类名，可在 touchCallback 回调中设置
	otherClass : 'xj-operate-other',		// 既不是鼠标也不是触屏，会在 classTarget 节点上添加的类名，默认是 'xj-operate-other'，但实际上这个状态并不会自动出现，页面只会在 mouse 和 touch 这两个状态中进行切换，除非是主动调用 otherSet()
	
	pressHover : false,						// 当处于 touch 状态时，如果长按屏幕且没有移动过，是否临时转遍为 mouse 状态，以便让 hover 生效，默认为 false
	delayTime : 500,						// touchstart 和 mousemove 的最大间隔时间，在此时间内触发连续触发这两个事件，将会进入 mouse 状态，默认为 500
	
	mouseCallback : function(temp){},		// 触发为 mouse 状态的回调函数，temporary 参数是这个状态是否为临时性转遍的标志，一般都是 true，除非调用 mouseSet() 时传入了 false，如果该函数最终返回的是 false，那么将会阻止本次进入 mouse 状态
	touchCallback : function(temp){},		// 触发为 touch 状态的回调函数，temporary 参数是这个状态是否为临时性转遍的标志，一般都是 true，除非调用 touchSet() 时传入了 false，如果该函数最终返回的是 false，那么将会阻止本次进入 touch 状态
	otherCallback : function(temp){},		// 既不是 mouse 也不是 touch 的回调函数，temporary 参数是调用 otherSet() 传入的参数，这个函数返回 false 将阻止进入 other 状态，实际上 other 状态并不会自动出现，这回调只在调用 otherSet() 时响应
	
};
</script>
</textarea>

<hr />
</section>



<section>
<h2>判断原理</h2>

<p>如何判断当前是使用鼠标操作还是触屏操作？有些开发者会以浏览器是否支持 <code>touchstart</code> 事件做为依据，支持就认为是使用了触屏操作，然而这种判断方法并不可靠，因为支持该事件的设备，也可能是使用着鼠标进行操作的，使用鼠标的环境下设备也可能是支持触屏操作的，那么怎么做才更加准确呢？浏览器目前并没有提供任何关于用户操作模式的 API，但是我们可以曲折的实现，以下是判断的原理。</p>

<p>在支持触屏的环境下，常规的触屏点击会按顺序先触发 <code>touchstart</code> 再触发 <code>mousemove</code>，所以我们可以使用这两个事件的时间间隔来进行判断，如果 <code>touchstart</code> 和 <code>mousemove</code> 的触发时间间隔大于 <code>500ms</code>，那就认为这两个事件并非是同个点击操作导致的，所以此时是使用了鼠标，如果这两个事件的触发时间间隔小于 <code>500ms</code>，则认为它们是由于触屏点击而同时触发的，那么此时是使用了触屏。</p>

<p>之所以使用 <code>500</code> 毫秒进行判断，是因为在部分移动端的浏览器如 Safari(IOS) 中，<a target="_blank" href="https://stackoverflow.com/questions/12238587">点击相关的事件存在 300 毫秒的延迟</a>，而事件如果延迟 <code>500</code> 毫秒以上就是长按而不是点击了，所以小于 <code>500</code> 毫秒是比较适中的，兼顾到了延迟和长按，当然实际上判断操作还要考虑事件的真实性(<code>event.isTrusted</code>)和滚动或捏合缩放等，但这些都是插件的细节，就不过多讲述了，有兴趣的可自行查看插件源码。</p>

<hr />
</section>



<section>
<h2>项目备注</h2>

<p>01. <code>:hover</code> 和 <code>:active</code> 这两个伪类选择器在 Safari(IOS) 中存在问题，具体来讲就是如果目标节点无法被聚焦或点击时没有特殊效果，那么这个节点就无法正常响应这两个伪类选择器，解决这问题的常用手段有两种，一是给目标节点绑定 <code>touchstart</code> 事件，回调是个空函数也无所谓，二是给目标节点设置 <code>tabIndex</code> 属性，让节点变得可被聚焦，在之前 "让 hover 在触屏时无效" 的案例中，我们就采用了第二种方法来确保 <code>:hover</code> 伪类生效，但这个问题并不会出现在 <code>button</code> 和 <code>a</code> 这些本来就可聚焦或可点击的元素上。</p>

<p>02. 插件判断设备类型其实是动态的，因为存在触屏设备插上鼠标变成鼠标操控，或 PC 转为触屏模式如 Chrome 使用移动端模拟，所以动态监听下适应性会更好，但状态的改变还得等对应的事件被触发，也就是说改变并不是立刻生效的，起码得移动过鼠标或触屏过才行。</p>

<p>03. 有疑问或者发现 BUG，可到 GitHub 提 <a target="_blank" href="https://github.com/xjZone/xj.operate/issues">Issue</a>，如果觉得插件写得还行，在 GitHub 中为本项目点个 <a target="_blank" href="https://github.com/xjZone/xj.operate">★Star</a> 吧，感谢啦 ಠ‿ಠ ❤。</p>

<hr />
</section>



<!-- <section><button class="xjButton xjButton-md xjButton-default xjButton-square" type="button" title="changeTheme" style="position:fixed;z-index:40;right:16px;bottom:16px;border-radius:4px;" 
onclick="$('html').toggleClass('xj-base-black')"><i class="fa fa-lightbulb"></i></button></section> -->

<script>
// 可在引入插件前通过 xj.operateConfig['0.6.0'] 进行全局配置，注意中括号的值得和当前插件版本相同
if(window.xj === undefined){ xj = {} };
if(xj.operateConfig === undefined){ xj.operateConfig = {} };
xj.operateConfig['0.6.0'] = {
	
	classTarget : document.documentElement,		// 将被添加 existClass | mouseClass | touchClass | otherClass 类名的节点，默认 html 标签，建议保持默认别修改
	existClass : 'xj-operate-exist',			// 初始化后 classTarget 会被添加的类名，默认是 'xj-operate-exist'，可用于 CSS 判断是否有存在 xj.operate 插件
	
	mouseClass : 'xj-operate-mouse',			// 当使用了鼠标进行操作，会在 classTarget 节点上添加的类名，默认是 'xj-operate-mouse'，并不推荐修改，因为不少 xj 插件都是默认只响应这个类名，如果需要配置其他类名，可在 mouseCallback 回调中设置
	touchClass : 'xj-operate-touch',			// 当使用了触屏进行操作，会在 classTarget 节点上添加的类名，默认是 'xj-operate-touch'，并不推荐修改，因为不少 xj 插件都是默认只响应这个类名，如果需要配置其他类名，可在 touchCallback 回调中设置
	otherClass : 'xj-operate-other',			// 既不是鼠标也不是触屏，会在 classTarget 节点上添加的类名，默认是 'xj-operate-other'，但实际上这个状态并不会自动出现，页面只会在 mouse 和 touch 这两个状态中进行切换，除非是主动调用 otherSet()
	
	pressHover : true,							// 当处于 touch 状态时，如果长按屏幕且没有移动过，是否临时转遍为 mouse 状态，以便让 hover 生效，默认为 false
	delayTime : 500,							// touchstart 和 mousemove 的最大间隔时间，在此时间内触发连续触发这两个事件，将会进入 mouse 状态，默认为 500
	
	// 触发为 mouse 状态的回调函数，temporary 参数是这个状态是否为临时性转遍的标志，一般都是 true，除非调用 mouseSet() 时传入了 false，如果该函数最终返回的是 false，那么将会阻止本次进入 mouse 状态
	mouseCallback : function(tem){ document.documentElement.classList.add('isMouse'), document.documentElement.classList.remove('isTouch'); document.documentElement.classList.remove('isOther'); },
	
	// 触发为 touch 状态的回调函数，temporary 参数是这个状态是否为临时性转遍的标志，一般都是 true，除非调用 touchSet() 时传入了 false，如果该函数最终返回的是 false，那么将会阻止本次进入 touch 状态
	touchCallback : function(tem){ document.documentElement.classList.add('isTouch'), document.documentElement.classList.remove('isMouse'); document.documentElement.classList.remove('isOther'); },
	
	// 既不是 mouse 也不是 touch 的回调函数，temporary 参数是调用 otherSet() 传入的参数，这个函数返回 false 将阻止进入 other 状态，实际上 other 状态并不会自动出现，这回调只在调用 otherSet() 时响应
	otherCallback : function(tem){ document.documentElement.classList.add('isOther'), document.documentElement.classList.remove('isMouse'); document.documentElement.classList.remove('isTouch'); },
	
};
</script>

<!-- <script>document.write('<link rel="stylesheet" href="../dist/xj.operate.css?timeStamp='+ Date.now() +'" />')</script> -->
<script>document.write('<script src="../dist/xj.operate.js?timeStamp='+ Date.now() +'"><\/script>')</script>

<script>
console.log(xj.operate);
// {
// 	version : pub_version,		// 插件和配置的版本号
// 	
// 	mouse : false,				// 是否正处于 mouse 状态，是则返回 true，否则返回 fasle
// 	touch : false,				// 是否正处于 touch 状态，是则返回 true，否则返回 fasle
// 	other : false,				// 是否正处于 other 状态，是则返回 true，否则返回 fasle，实际上这个状态并不会自动出现，除非是手动调用了 otherSet()
// 	
// 	mouseSet : pub_nothing,		// 手动设置为 mouse 状态，可传入 temporary 参数，不传则默认为 true，也就是设置为 mouse 状态是临时的，传入 false 则永久性进入 mouse 状态，之后就得用 mouseSet() / touchSet() 方法才能恢复继续监听
// 	touchSet : pub_nothing,		// 手动设置为 touch 状态，可传入 temporary 参数，不传则默认为 true，也就是设置为 touch 状态是临时的，传入 false 则永久性进入 touch 状态，之后就得用 mouseSet() / touchSet() 方法才能恢复继续监听
// 	otherSet : pub_nothing,		// 手动设置为 other 状态，可传入 temporary 参数，不传则默认为 true，也就是设置为 other 状态是临时的，传入 false 则永久性进入 other 状态，之后就得用 mouseSet() / touchSet() 方法才能恢复继续监听
// 	
// }
</script>



</body>
</html>


